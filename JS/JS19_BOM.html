【BOM】

# BOM概述

JS / DOM / BOM

浏览器对象模型，独立于内容于浏览器窗口进行交互的对象，核心对象是window

BOM由一系列相关对象构成，含多种属性和方法

BOM缺乏标准，兼容性较差，JS语法的标准化组织是ECMA，DOM的标准化组织是W3C，BOM最初是Netscape浏览器标准的一部分


DOM/BOM对比

DOM
- 文档对象模型
- DOM 就是把文档当作对象来看
- DOM 的顶级对象是document
- DOM 主要学习的是操作页面元素
- DOM 是W3C的标准规范

BOM
- 浏览器对象模型
- 把浏览器当作对象来看
- BOM 的顶级对象是window
- BOM 学习的是浏览器窗口交互的一些对象
- BOM 是浏览器厂商在各自浏览器上定义的，兼容性较差

BOM 比 DOM 更大，包含 DOM

window
- document
- location
- navigation
- screen
- history

window对象是浏览器的顶级对象，有双重角色
- JS 访问浏览器窗口的一个接口
- 是全局对象，定义在全局作用域中的变量，函数都会变成window对象的属性和方法

调用时可以省略window,如alert(), prompt()
window.alert()
window.prompt()



<script>
	window.document.querySelector();
	var num = 0; //num为全局对象,自动变成windows的属性
	console.log(window.num);

	function fn() {
		console.log(11);
	}
	fn();
	window.fn(); //fn() 为全局作用域下的函数

	console.dir(window);
	console.dir(window.name); //name本身有意义，不要随便命名变量为name
</script>


# window对象的常见事件

## 页面加载事件

<button>点击</button>

<script>
	var btn = document.querySelector('button');
	btn.addEventListener('click', function () {
		alert('click me');
	})
	//问题来了：把JS写到button上方就无效了，如何解决？
</script>

1.window.onload是窗口加载事件，当文档内容完全加载完成（包括图片、脚本文件、CSS文件等）会触发该事件，然后调用处理函数

2.window.onload传统注册方式只能写一次，如果有多个，会以最后一个window.onload为准

3.若使用addEventListener则没有限制

<script>
	//窗口加载事件
	// 传统方式
	window.onload = function () { }
	// addEventListener方式
	window.addEventListener('load', function () { })

	//还有一个类似的，DOMContentLoaded事件触发是，仅当DOM加载完成，不包括样式表、图片、flash等，IE9+支持
	document.addEventListener('DOMContentLoaded', function () { })

	//如果页面的图片很多，从用户访问到onload触发可能需要较长时间，交互效果就不能实现，必然影响用户体验，此时用DOMContentLoaded比较合适

</script>


<script>
	window.onload = function () {  //这样就可以把JS放在页面任意位置
		var btn = document.querySelector('button');
		btn.addEventListener('click', function () {
			alert('click me');
		})
	}

	window.onload = function () {
		alert('22');       //传统方式只能注册一次，第二次会覆盖第一次
	}

	window.addEventListener('load', function () {
		var btn = document.querySelector('button');
		btn.addEventListener('click', function () {
			alert('click me');
		})
	})

	window.addEventListener('load', function () {
		alert('22');   //addEventListener方式无限制
	})

	document.addEventListener('DOMCintentLoaded', function () {
		alert('33');  //DOMCintentLoaded比load加载更快，先弹33
	})
</script>

## 调整窗口大小事件



<script>
	window.onresize = function () { }
	window.addEventListener('resize', function () { })
</script>

window.onresize 是调整窗口大小的加载事件，当触发时就会调用处理函数

1. 只要窗口发生像素变化，就会触发该事件
2. 常利用该事件完成响应式布局，
window.innerWidth当前屏幕宽度
window.innerHeight当前屏幕高度

<style>
	div {
		width: 200px;
		height: 200px;
		background-color: pink;
	}
</style>

<script>
	window.addEventListener('load', function () {
		var div = document.querySelector('div');
		window.addEventListener('resize', function () {
			console.log('changed');
			if (window.innerWidth <= 800) {
				div.style.display = 'none';
			} else {
				div.style.display = 'block';
			}
		})
	})
</script>
<div>123</div>


# 定时器

window对象提供了2种好用的方法：定时器

## 设置定时器

<script>
	window.setTimeout(function () { }, [delayedTimeInMM]);

	// setTimeout() 用于设置一个定时器，在定时器到期后执行函数
	// window可省,延时时间为毫秒，可省，默认为0
	// 调用函数可以写函数，也可以写函数名 还可以写 'function()'
	// 多个定时器加标识符
</script>

<script>

	// 方式1：直接写函数
	setTimeout(function () {
		console.log('Time out!');
	})


	// 方式2：函数名调用
	function callback() {
		console.log('boom!');
	}
	var time1 = setTimeout(callback, 3000); //这里调用了callback函数
	var time2 = setTimeout('callback()', 5000); //这种写法也能实现功能，但是不提倡

</script>

setTimeout()这个函数我们也称为*回调函数 callback*
普通函数按照代码顺序直接调用，而这个函数需要等待时间，时间到了才去调用函数，因此称为回调函数

以前所讲的
element.onclick = function(){}
element.addEventListener('click',function(){})
里面的函数都是回调函数


## 案例：5秒后关闭广告

- 5秒后，隐藏广告
- 用定时器，setTimeout()

<img src="images/open.png" alt="">
<script>
	var ad = document.querySelector('.ad');
	setTimeout(function () {
		ad.style.display = 'none';
	}, 5000);  //5秒后隐藏
</script>

## 停止定时器

<script>
	window.clearTimeout(timeoutID);

	// window可以省略
	// 括号里的参数是定时器的标识符
</script>

<button>stop timeout</button>
<script>
	var btn = document.querySelector('button');
	var timeout007 = setTimeout(function () {
		console.log('boom');
	}, 2000);

	btn.addEventListener('click', function () {
		clearTimeout(timeout007);
	})
</script>

## setInterval() 定时器

<script>
	window.setInterval(回调函数, [间隔的毫秒数]);

	// 该方法重复调用一个函数，每隔这个时间，就去调用一次回调函数

	// window可以省略
	// 调用函数可以直接写函数、写函数名、字符串'函数名()'三种形式
	// 间隔的毫秒数省略默认是0，如果写必须是毫秒，表示间隔多少毫秒就自动调用这个函数
	// 建议给定时器赋值一个标识符
</script>

<script>
	setInterval(function () {
		console.log('something');
	}, 1000);

	// setTimeout 延时时间到了，就去调用这个函数，只调用一次，然后结束该定时器
	// setInterval 每隔一段时间，就去调用这个函数，会调用很多次，重复调用这个函数
</script>

## 案例：京东秒杀倒计时

分析
- 倒计时是不断变化的，因此需要定时器来自动变化 setInterval
- 三个黑色盒子存放时分秒
- 三个盒子的innerHTML放入计算的时、分、秒数
- 首次执行的时候也有间隔毫秒数，因此刷新页面会有空白
- 最好采取封装函数的形式，这样可以先调用一次这个函数，防止刚开始刷新页面时有空白这一问题

<div>
	<span class="hour">1</span>
	<span class="minute">2</span>
	<span class="second">3</span>
</div>

<script>
	var hour = document.querySelector('.hour');
	var minute = document.querySelector('.minute');
	var second = document.querySelector('.second');
	var inputTime = +new Date('2020-01-01 18:00:00');

	countDown(); //先调用一次，防止刷新出现空白
	setInterval(countDown, 1000);//开启定时器

	function countDown() {
		var nowTime = +new Date();
		var times = (inputTime - nowTime) / 1000;

		h = parseInt(times / 60 / 60 % 24);
		m = parseInt(times / 60 % 60);
		s = parseInt(times % 60);

		h = h < 10 ? '0' + h : h;
		m = m < 10 ? '0' + m : m;
		s = s < 10 ? '0' + s : s;

		hour.innerHTML = h;
		minute.innerHTML = m;
		second.innerHTML = s;
	}
</script>

## 停止 setInterval() 定时器

<script>
	window.clearInterval(intervalID);

	// window可以省略
	// 里面的参数就是定时器的标识符
</script>


<button class="begin">turn on timer</button>
<button class="stop">turn off timer</button>

<script>
	var begin = document.querySelector('.begin');
	var stop = document.querySelector('.stop');

	var timer = null; //全局变量，null为一个空对象，一定要赋一个值，否则为undefined

	begin.addEventListener('click', function () {
		timer = setInterval(function () {
			// 这里不要用var timer=... 因为只是声明了函数内的局部变量，stop的事件函数无法访问	
			//函数里没有声明的变量当全局变量使用
			console.log('hello');
		}, 1000)
	})

	stop.addEventListener('click', function () {
		clearInterval(timer);
	})

</script>

## 案例：发送短信

点击按钮后，该按钮60秒内不能再次点击，防止重复发送短信

[文本输入框]【按钮】

- 点击按钮后，禁用disabled为true
- 同时按钮内容发生变化，注意button里面的内容通过innerHTML修改
- 秒数发生变化，需要定时器
- 定义一个变量，在定时器里面不断递减
- 如果变量为0，说明到了时间，停止定时器，并且复原初始状态


手机号码：<input type="text">
<button>发送</button>

<script>
	var btn = document.querySelector('button');
	var seconds = 3;  //定义剩下的秒数
	btn.addEventListener('click', function () {
		btn.disabled = true;
		var timer = setInterval(function () {
			if (seconds == 0) {
				// 清楚定时器、复原按钮
				clearInterval(timer);
				btn.disabled = false;
				btn.innerHTML = '发送';
				seconds = 3;  //这里一定要恢复初始值
			} else {
				btn.innerHTML = '还剩' + seconds + '秒再次点击';
				seconds--;
			}
		}, 1000)
	})
</script>


P86.over
https://www.bilibili.com/video/BV1k4411w7sV?p=87

# JS执行机制

# location对象

# naviagator对象

# history对象